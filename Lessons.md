## Оглавление

- [Неделя 1. Основы языка Go](#неделя-1-основы-языка-go)
  - [День 1. Введение в Go](#день-1-введение-в-go)
  - [День 2. Переменные, типы данных и константы](#день-2-переменные-типы-данных-и-константы)
  - [День 3. Операторы и выражения](#день-3-операторы-и-выражения)
  - [День 4. Функции](#день-4-функции)
  - [День 5. Циклы](#день-5-циклы)
  - [День 6. Ввод и вывод данных](#день-6-ввод-и-вывод-данных)
  - [День 7. Итоги первой недели](#день-7-итоги-первой-недели)
- [Неделя 2. Структуры данных и управление памятью](#неделя-2-структуры-данных-и-управление-памятью)
  - [День 8. Массивы и срезы](#день-8-массивы-и-срезы)
  - [День 9. Карты (map) и множества](#день-9-карты-map-и-множества)
  - [День 10. Структуры](#день-10-структуры)
  - [День 11. Указатели](#день-11-указатели)
  - [День 12. Интерфейсы](#день-12-интерфейсы)
  - [День 13. Обработка ошибок](#день-13-обработка-ошибок)
  - [День 14. Итоги второй недели](#день-14-итоги-второй-недели)
- [Неделя 3. Расширенные возможности Go](#неделя-3-расширенные-возможности-go)
  - [День 15. Горутины и каналы](#день-15-горутины-и-каналы)
  - [День 16. Работа с файлами](#день-16-работа-с-файлами)
  - [День 17. HTTP и веб-серверы](#день-17-http-и-веб-серверы)
  - [День 18. JSON и работа с API](#день-18-json-и-работа-с-api)
  - [День 19. Базы данных (SQL и NoSQL)](#день-19-базы-данных-sql-и-nosql)
  - [День 20. Тестирование и отладка](#день-20-тестирование-и-отладка)
  - [День 21. Финальный проект и итоги курса](#день-21-финальный-проект-и-итоги-курса)

---

## Неделя 1. Основы языка Go

## День 1. Введение в Go

### 1. История и особенности Go
Go (или Golang) был разработан в Google в 2007 году Робертом Грисемером, Робом Пайком и Кеном Томпсоном. Его главные особенности:
- Простота синтаксиса (меньше магии, больше читаемости).
- Высокая производительность (компилируется в машинный код).
- Встроенная поддержка конкурентности (горутины и каналы).
- Автоматическое управление памятью (GC).

### 2. Установка Go и настройка среды
1. [Скачать Go](https://go.dev/dl/) и установить.
2. Проверить установку:
    ```sh
    go version
    ```
3. Установить **VS Code** (с плагином Go) или **GoLand**.
4. Создать рабочую папку для проектов.
5. Установить переменную окружения `GOPATH`.

### 3. Первая программа на Go
Создадим файл `main.go` и напишем первую программу:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```
Запустить командой:
```sh
go run main.go
```

### 4. Компиляция и запуск программ
```sh
go build main.go
./main  # Запуск исполняемого файла
```

### 5. Самостоятельная работа
1. Написать программу, которая выводит ваше имя и возраст.
2. Скомпилировать её и запустить.
3. Дополнительно: запросить ввод имени и возраста от пользователя и вывести в формате `Hello, [имя]! You are [возраст] years old.`

---

## День 2. Переменные, типы данных и константы

### 1. Объявление переменных (`var`, `:=`)
```go
var age int = 20
var name string = "Boris"
isStudent := true // Краткая запись
```
**Важно!** Вне функции `:=` нельзя использовать, только `var`.

### 2. Основные типы данных
| Тип       | Описание                      | Пример |
|-----------|--------------------------------|--------|
| `int`     | Целые числа                   | `var x int = 10` |
| `float64` | Числа с плавающей точкой       | `var y float64 = 3.14` |
| `string`  | Строки                         | `var s string = "Hello"` |
| `bool`    | Логические значения `true/false` | `var isGoCool bool = true` |

### 3. Константы (`const`)
```go
const Pi = 3.1415
const Greeting = "Hello, Go!"
```
Константы нельзя изменять после объявления.

### 4. Самостоятельная работа
1. Создать программу, в которой объявить переменные: имя, возраст, рост (`float64`) и студент ли ты (`bool`).
2. Вывести их на экран.
3. Добавить константу с твоим любимым числом и тоже вывести её.

---

## День 3. Операторы и выражения

### 1. Арифметические операции
```go
sum := 10 + 3  // 13
diff := 10 - 3 // 7
prod := 10 * 3 // 30
quot := 10 / 3 // 3 (int деление)
rem := 10 % 3  // 1 (остаток от деления)
```
**Важно!** Если делишь два `int`, то результат будет `int`, без дробной части. Если хочешь получить `float64`, хотя бы одно число должно быть `float64`:
```go
c := float64(a) / float64(b) // 3.3333
```

### 2. Операторы сравнения
```go
fmt.Println(10 > 5)   // true
fmt.Println(10 < 5)   // false
fmt.Println(10 == 10) // true
fmt.Println(10 != 5)  // true
```

### 3. Логические операторы
```go
fmt.Println(true && false) // false
fmt.Println(true || false) // true
fmt.Println(!true)         // false
```

### 4. Условные операторы (`if`, `switch`)
```go
if age >= 18 {
    fmt.Println("Ты совершеннолетний.")
} else {
    fmt.Println("Ты еще ребенок.")
}
```
```go
switch day {
case 1:
    fmt.Println("Понедельник")
case 2:
    fmt.Println("Вторник")
case 3:
    fmt.Println("Среда")
default:
    fmt.Println("Неизвестный день")
}
```
**Важно!** В `switch` можно использовать `fallthrough`, чтобы не прерывать выполнение следующего case:
```go
switch day {
case 1:
    fmt.Println("Понедельник")
    fallthrough
case 2:
    fmt.Println("Вторник")
}
```
Выведет сразу оба дня.

### 5. Самостоятельная работа
1. Написать программу, которая запрашивает у пользователя число и говорит, положительное оно, отрицательное или ноль.
2. Написать программу, которая определяет, является ли введённое число четным или нечётным.

## **День 4: Функции**

### **Что изучим:**
- Определение и вызов функций
- Аргументы и возвращаемые значения
- Множественные возвращаемые значения

### **Пример 1: Простая функция**
```go
func greet(name string) {
    fmt.Println("Hello,", name)
}

greet("Boris")
// Вывод: Hello, Boris
```

### **Пример 2: Функция с возвратом значения**
```go
func sum(a, b int) int {
    return a + b
}

result := sum(5, 10)
fmt.Println(result) // 15
```

### **Самостоятельная работа:**
1. Написать функцию, которая принимает два числа и возвращает их сумму, разность и произведение.
2. Вызвать её в `main` и вывести результаты.

---

## **День 5: Циклы**

### **Пример 1: Классический `for`**
```go
for i := 1; i <= 5; i++ {
    fmt.Println(i)
}
```

### **Пример 2: Итерация по срезу**
```go
nums := []int{1, 2, 3, 4, 5}
for index, value := range nums {
    fmt.Println(index, value)
}
```

### **Самостоятельная работа:**
1. Написать программу, которая вычисляет сумму чисел от 1 до N (вводится пользователем).

---

## **День 6: Ввод и вывод данных**

### **Пример 1: Чтение числа от пользователя**
```go
var num int
fmt.Print("Введите число: ")
fmt.Scan(&num)
fmt.Println("Вы ввели:", num)
```

### **Пример 2: Калькулятор**
```go
var a, b int
var op string

fmt.Print("Введите два числа: ")
fmt.Scan(&a, &b)

fmt.Print("Введите операцию (+, -, *, /): ")
fmt.Scan(&op)

switch op {
case "+":
    fmt.Println("Результат:", a+b)
case "-":
    fmt.Println("Результат:", a-b)
case "*":
    fmt.Println("Результат:", a*b)
case "/":
    if b != 0 {
        fmt.Println("Результат:", a/b)
    } else {
        fmt.Println("Ошибка: деление на ноль")
    }
default:
    fmt.Println("Неизвестная операция")
}
```

### **Самостоятельная работа:**
1. Написать калькулятор, который принимает два числа и оператор (+, -, *, /) и выводит результат.

---

## **День 7: Итоги первой недели**

### **Тестовые вопросы:**
1. Как объявить переменную в Go?
2. Как работает оператор `:=`?
3. Чем отличается `switch` от `if-else`?

### **Самостоятельная работа:**
1. Написать программу, которая проверяет, является ли число чётным или нечётным.

---

## **День 8: Массивы и срезы**

### **Пример 1: Массив**
```go
var arr [3]int = [3]int{1, 2, 3}
fmt.Println(arr[0]) // 1
```

### **Пример 2: Срез**
```go
nums := []int{10, 20, 30}
nums = append(nums, 40)
fmt.Println(nums) // [10 20 30 40]
```

### **Самостоятельная работа:**
1. Написать программу, которая сортирует массив чисел (использовать `sort.Ints`).

---

## **День 9: Карты (map) и множества**

### Что такое карта (map) в Go?

Карта (map) — это встроенный тип данных в Go, который представляет собой коллекцию пар "ключ-значение". Карты используются для хранения данных, где каждое значение связано с уникальным ключом. Это похоже на словарь в других языках программирования, таких как Python или JavaScript.

### Основные характеристики карт:
- **Ключи** должны быть уникальными.
- **Значения** могут быть любого типа.
- Карты не сохраняют порядок элементов (в отличие от массивов или срезов).
- Карты динамически расширяются по мере добавления новых элементов.

### Для чего используются карты?

Карты полезны в следующих случаях:
1. **Хранение данных с быстрым доступом по ключу.** Например, словарь переводов, где ключ — это слово на одном языке, а значение — перевод на другой язык.
2. **Подсчёт частоты элементов.** Например, подсчёт количества вхождений каждого слова в тексте.
3. **Кэширование данных.** Например, хранение результатов вычислений для быстрого доступа в будущем.
4. **Группировка данных.** Например, группировка студентов по их возрасту или городу.

### Пример 1: Карта (словарь)

### Создание карты
Карта создаётся с помощью ключевого слова `map` и указания типов ключа и значения. Например:

```go
// Создание карты с ключами типа string и значениями типа int
grades := map[string]int{
    "Alice": 90,
    "Bob":   85,

## Получение значения по ключу

Чтобы получить значение по ключу, используйте синтаксис `map[ключ]`:

```go
fmt.Println(grades["Alice"]) // 92
```

Если ключ отсутствует в карте, возвращается нулевое значение для типа значения (например, 0 для int).

## Проверка наличия ключа

Чтобы проверить, существует ли ключ в карте, используйте второй возвращаемый параметр:

```go
value, exists := grades["Bob"]
if exists {
    fmt.Println("Bob's grade is", value)
} else {
    fmt.Println("Bob is not in the map")
}
```

## Удаление элемента

Элемент удаляется с помощью функции `delete`:

```go
delete(grades, "Bob") // Удаление элемента с ключом "Bob"
```

## Итерация по карте

Для перебора всех элементов карты используйте цикл `for` с `range`:

```go
for key, value := range grades {
    fmt.Println(key, "has a grade of", value)
}
```

## Пример 2: Подсчёт частоты слов

Карты часто используются для подсчёта частоты элементов. Например, подсчитаем, сколько раз каждое слово встречается в тексте:

```go
text := "hello world hello go world go hello"
words := strings.Fields(text) // Разбиваем текст на слова

wordCount := make(map[string]int) // Создаём карту для подсчёта

for _, word := range words {
    wordCount[word]++ // Увеличиваем счётчик для каждого слова
}

fmt.Println(wordCount) // map[go:2 hello:3 world:2]
```

## Самостоятельная работа

Создайте карту, которая хранит переводы слов с английского на русский. Например:

- "apple" → "яблоко"
- "cat" → "кот"
- "dog" → "собака"

Напишите программу, которая запрашивает у пользователя слово на английском и выводит его перевод на русский. Если слово отсутствует в карте, выведите сообщение "Перевод не найден".

Добавьте возможность добавлять новые слова и их переводы в карту.

## Заключение

Карты — это мощный инструмент в Go, который позволяет эффективно хранить и обрабатывать данные в формате "ключ-значение". Они особенно полезны для задач, где требуется быстрый доступ к данным по ключу, таких как словари, подсчёт частот или кэширование. Освоение работы с картами — важный шаг в изучении Go.


## **День 10: Структуры**

### **Пример 1: Структура**
```go
type Person struct {
    Name string
    Age  int
}

p := Person{"Boris", 20}
fmt.Println(p.Name) // Boris
```

### **Самостоятельная работа:**
1. Создать структуру `Человек` с полями `Имя`, `Возраст`, `Город`.

## **День 11: Указатели**

### **Что изучим:**
- Объявление указателей
- Разыменование указателей
- Передача по ссылке

### **Пример 1: Использование указателей**
```go
var a int = 10
var ptr *int = &a // ptr хранит адрес переменной a
fmt.Println(ptr)   // Выведет адрес переменной a
fmt.Println(*ptr)  // Разыменование, получаем 10
```

### **Пример 2: Функция, изменяющая переменную через указатель**
```go
func updateValue(x *int) {
    *x = *x + 10
}

num := 5
updateValue(&num)
fmt.Println(num) // 15
```

### **Самостоятельная работа:**
1. Написать функцию, которая увеличивает переданное число в два раза, используя указатель.

---

# День 12: Интерфейсы

## Что изучим:
- Определение интерфейсов
- Использование интерфейсов

## Что такое интерфейсы в Go?
Интерфейсы в Go — это способ определения набора методов, которые должны быть реализованы другими типами. Интерфейсы позволяют абстрагироваться от конкретной реализации и работать с объектами через их поведение, а не через их тип.

### Основные характеристики интерфейсов:
- Интерфейс определяет сигнатуры методов (название, параметры и возвращаемые значения), но не их реализацию.
- Любой тип, который реализует все методы интерфейса, автоматически удовлетворяет этому интерфейсу.
- Интерфейсы позволяют писать гибкий и переиспользуемый код.

## Пример 1: Простой интерфейс

### Определение интерфейса
Интерфейс определяется с помощью ключевого слова `interface`. Например, создадим интерфейс `Speaker`, который требует реализации метода `Speak()`:

```go
type Speaker interface {
    Speak() string
}
```

### Реализация интерфейса
Любой тип, который реализует метод `Speak()`, автоматически удовлетворяет интерфейсу `Speaker`. Например:

```go
type Person struct {
    Name string
}

// Реализация метода Speak для типа Person
func (p Person) Speak() string {
    return "Hello, my name is " + p.Name
}
```

### Использование интерфейса
Теперь мы можем использовать интерфейс `Speaker` для работы с объектами типа `Person`:

```go
func main() {
    p := Person{Name: "Alice"}
    var s Speaker = p // Person удовлетворяет интерфейсу Speaker
    fmt.Println(s.Speak()) // Вывод: Hello, my name is Alice
}
```

## Пример 2: Интерфейс с несколькими методами

Интерфейсы могут требовать реализации нескольких методов. Например, создадим интерфейс `Shape`, который определяет методы для вычисления площади и периметра:

```go
type Shape interface {
    Area() float64
    Perimeter() float64
}
```

### Реализация интерфейса для разных типов

Теперь реализуем интерфейс `Shape` для двух типов: `Circle` и `Rectangle`.

#### Тип Circle

```go
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}
```

#### Тип Rectangle

```go
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}
```

### Использование интерфейса
Теперь мы можем использовать интерфейс `Shape` для работы с объектами `Circle` и `Rectangle`:

```go
func printShapeInfo(s Shape) {
    fmt.Printf("Area: %.2f, Perimeter: %.2f
", s.Area(), s.Perimeter())
}

func main() {
    c := Circle{Radius: 5}
    r := Rectangle{Width: 10, Height: 5}

    printShapeInfo(c) // Вывод: Area: 78.54, Perimeter: 31.42
    printShapeInfo(r) // Вывод: Area: 50.00, Perimeter: 30.00
}
```

## Пример 3: Пустой интерфейс

Пустой интерфейс (`interface{}`) не требует реализации каких-либо методов. Это позволяет работать с любыми типами данных. Например:

```go
func printValue(v interface{}) {
    fmt.Println("Value:", v)
}

func main() {
    printValue(42)         // Вывод: Value: 42
    printValue("Hello")    // Вывод: Value: Hello
    printValue(3.14)       // Вывод: Value: 3.14
}
```

Пустые интерфейсы часто используются в функциях, которые должны принимать данные любого типа, например, в функциях для работы с JSON или базами данных.

## Самостоятельная работа

Создайте интерфейс `Animal` с методами `Sound()` (звук, который издает животное) и `Move()` (способ передвижения).

Реализуйте интерфейс `Animal` для типов `Dog`, `Cat` и `Bird`.

Напишите функцию, которая принимает объект типа `Animal` и выводит информацию о звуке и способе передвижения.

## Заключение

Интерфейсы в Go — это мощный инструмент для создания гибкого и переиспользуемого кода. Они позволяют абстрагироваться от конкретной реализации и работать с объектами через их поведение. Освоение интерфейсов — важный шаг в изучении Go, который открывает возможности для написания более модульных и тестируемых программ.

## Тестовые вопросы
1. Что такое интерфейс в Go?
2. Какой тип может удовлетворять интерфейсу?
3. Для чего используется пустой интерфейс (`interface{}`)?
4. Как проверить, что тип реализует интерфейс?

## **День 13: Обработка ошибок**

### **Что изучим:**
- Встроенный интерфейс `error`
- Использование `panic` и `recover`

### **Пример 1: Создание ошибки**
```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("деление на ноль")
    }
    return a / b, nil
}
```

### **Самостоятельная работа:**
1. Написать функцию деления двух чисел, которая обрабатывает деление на ноль.

---

## **День 14: Итоги второй недели**

### **Тестовые вопросы:**
1. Чем срезы отличаются от массивов?
2. Как создать карту (`map`)?
3. Как работают указатели в Go?

### **Самостоятельная работа:**
1. Написать программу, которая использует указатели, структуры и интерфейсы.

---

## **День 15: Горутины и каналы**

### **Что изучим:**
- Запуск горутин
- Взаимодействие через каналы

### **Пример 1: Запуск горутины**
```go
func printMessage() {
    fmt.Println("Hello from goroutine!")
}

go printMessage()
time.Sleep(time.Second)
```

### **Пример 2: Каналы**
```go
ch := make(chan string)

go func() {
    ch <- "Привет из горутины"
}()

fmt.Println(<-ch)
```

### **Самостоятельная работа:**
1. Написать программу, которая запускает несколько горутин для обработки данных через каналы.

## **День 16: Работа с файлами**

### **Что изучим:**
- Чтение и запись в файлы

### **Пример 1: Запись в файл**
```go
file, _ := os.Create("example.txt")
defer file.Close()
file.WriteString("Hello, Go!")
```

### **Пример 2: Чтение файла**
```go
data, _ := os.ReadFile("example.txt")
fmt.Println(string(data))
```

### **Самостоятельная работа:**
1. Написать программу, которая считывает файл и выводит его содержимое в консоль.


## **День 17: HTTP и веб-серверы**

### **Пример: Простой сервер**
```go
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintln(w, "Hello, World!")
})
http.ListenAndServe(":8080", nil)
```

### **Самостоятельная работа:**
1. Реализовать простой HTTP-сервер, который отвечает "Hello, World!".


## **День 18: JSON и работа с API**

### **Пример: Кодирование JSON**
```go
type User struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
}
user := User{"Alice", 30}
jsonData, _ := json.Marshal(user)
fmt.Println(string(jsonData))
```

### **Самостоятельная работа:**
1. Написать клиент для получения данных о погоде через API.

## **День 19: Базы данных (SQL и NoSQL)**

### **Пример: Подключение к SQLite**
```go
db, _ := sql.Open("sqlite3", "data.db")
defer db.Close()
```

### **Самостоятельная работа:**
1. Реализовать простую базу данных пользователей с возможностью добавления и поиска.

## **День 20: Тестирование и отладка**

### **Пример: Написание теста**
```go
func TestSum(t *testing.T) {
    result := sum(2, 3)
    if result != 5 {
        t.Errorf("Expected 5, got %d", result)
    }
}
```

### **Самостоятельная работа:**
1. Написать тесты для одной из предыдущих программ.


## **День 21: Финальный проект и итоги курса**

### **Финальное задание:**
1. Разработать веб-приложение (например, TODO-лист) с базой данных и API.

