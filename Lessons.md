## Оглавление

- [Неделя 1. Основы языка Go](#неделя-1-основы-языка-go)
  - [День 1. Введение в Go](#день-1-введение-в-go)
  - [День 2. Переменные, типы данных и константы](#день-2-переменные-типы-данных-и-константы)
  - [День 3. Операторы и выражения](#день-3-операторы-и-выражения)
  - [День 4. Функции](#день-4-функции)
  - [День 5. Циклы](#день-5-циклы)
  - [День 6. Ввод и вывод данных](#день-6-ввод-и-вывод-данных)
  - [День 7. Итоги первой недели](#день-7-итоги-первой-недели)
- [Неделя 2. Структуры данных и управление памятью](#неделя-2-структуры-данных-и-управление-памятью)
  - [День 8. Массивы и срезы](#день-8-массивы-и-срезы)
  - [День 9. Карты (map) и множества](#день-9-карты-map-и-множества)
  - [День 10. Структуры](#день-10-структуры)
  - [День 11. Указатели](#день-11-указатели)
  - [День 12. Интерфейсы](#день-12-интерфейсы)
  - [День 13. Обработка ошибок](#день-13-обработка-ошибок)
  - [День 14. Итоги второй недели](#день-14-итоги-второй-недели)
- [Неделя 3. Расширенные возможности Go](#неделя-3-расширенные-возможности-go)
  - [День 15. Горутины и каналы](#день-15-горутины-и-каналы)
  - [День 16. Работа с файлами](#день-16-работа-с-файлами)
  - [День 17. HTTP и веб-серверы](#день-17-http-и-веб-серверы)
  - [День 18. JSON и работа с API](#день-18-json-и-работа-с-api)
  - [День 19. Базы данных (SQL и NoSQL)](#день-19-базы-данных-sql-и-nosql)
  - [День 20. Тестирование и отладка](#день-20-тестирование-и-отладка)
  - [День 21. Финальный проект и итоги курса](#день-21-финальный-проект-и-итоги-курса)

---

## Неделя 1. Основы языка Go

## День 1. Введение в Go

### 1. История и особенности Go
Go (или Golang) был разработан в Google в 2007 году Робертом Грисемером, Робом Пайком и Кеном Томпсоном. Его главные особенности:
- Простота синтаксиса (меньше магии, больше читаемости).
- Высокая производительность (компилируется в машинный код).
- Встроенная поддержка конкурентности (горутины и каналы).
- Автоматическое управление памятью (GC).

### 2. Установка Go и настройка среды
1. [Скачать Go](https://go.dev/dl/) и установить.
2. Проверить установку:
    ```sh
    go version
    ```
3. Установить **VS Code** (с плагином Go) или **GoLand**.
4. Создать рабочую папку для проектов.
5. Установить переменную окружения `GOPATH`.

### 3. Первая программа на Go
Создадим файл `main.go` и напишем первую программу:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```
Запустить командой:
```sh
go run main.go
```

### 4. Компиляция и запуск программ
```sh
go build main.go
./main  # Запуск исполняемого файла
```

### 5. Самостоятельная работа
1. Написать программу, которая выводит ваше имя и возраст.
2. Скомпилировать её и запустить.
3. Дополнительно: запросить ввод имени и возраста от пользователя и вывести в формате `Hello, [имя]! You are [возраст] years old.`

---

## День 2. Переменные, типы данных и константы

### 1. Объявление переменных (`var`, `:=`)
```go
var age int = 20
var name string = "Boris"
isStudent := true // Краткая запись
```
**Важно!** Вне функции `:=` нельзя использовать, только `var`.

### 2. Основные типы данных
| Тип       | Описание                      | Пример |
|-----------|--------------------------------|--------|
| `int`     | Целые числа                   | `var x int = 10` |
| `float64` | Числа с плавающей точкой       | `var y float64 = 3.14` |
| `string`  | Строки                         | `var s string = "Hello"` |
| `bool`    | Логические значения `true/false` | `var isGoCool bool = true` |

### 3. Константы (`const`)
```go
const Pi = 3.1415
const Greeting = "Hello, Go!"
```
Константы нельзя изменять после объявления.

### 4. Самостоятельная работа
1. Создать программу, в которой объявить переменные: имя, возраст, рост (`float64`) и студент ли ты (`bool`).
2. Вывести их на экран.
3. Добавить константу с твоим любимым числом и тоже вывести её.

---

## День 3. Операторы и выражения

### 1. Арифметические операции
```go
sum := 10 + 3  // 13
diff := 10 - 3 // 7
prod := 10 * 3 // 30
quot := 10 / 3 // 3 (int деление)
rem := 10 % 3  // 1 (остаток от деления)
```
**Важно!** Если делишь два `int`, то результат будет `int`, без дробной части. Если хочешь получить `float64`, хотя бы одно число должно быть `float64`:
```go
c := float64(a) / float64(b) // 3.3333
```

### 2. Операторы сравнения
```go
fmt.Println(10 > 5)   // true
fmt.Println(10 < 5)   // false
fmt.Println(10 == 10) // true
fmt.Println(10 != 5)  // true
```

### 3. Логические операторы
```go
fmt.Println(true && false) // false
fmt.Println(true || false) // true
fmt.Println(!true)         // false
```

### 4. Условные операторы (`if`, `switch`)
```go
if age >= 18 {
    fmt.Println("Ты совершеннолетний.")
} else {
    fmt.Println("Ты еще ребенок.")
}
```
```go
switch day {
case 1:
    fmt.Println("Понедельник")
case 2:
    fmt.Println("Вторник")
case 3:
    fmt.Println("Среда")
default:
    fmt.Println("Неизвестный день")
}
```
**Важно!** В `switch` можно использовать `fallthrough`, чтобы не прерывать выполнение следующего case:
```go
switch day {
case 1:
    fmt.Println("Понедельник")
    fallthrough
case 2:
    fmt.Println("Вторник")
}
```
Выведет сразу оба дня.

### 5. Самостоятельная работа
1. Написать программу, которая запрашивает у пользователя число и говорит, положительное оно, отрицательное или ноль.
2. Написать программу, которая определяет, является ли введённое число четным или нечётным.

## **День 4: Функции**

### **Что изучим:**
- Определение и вызов функций
- Аргументы и возвращаемые значения
- Множественные возвращаемые значения

### **Пример 1: Простая функция**
```go
func greet(name string) {
    fmt.Println("Hello,", name)
}

greet("Boris")
// Вывод: Hello, Boris
```

### **Пример 2: Функция с возвратом значения**
```go
func sum(a, b int) int {
    return a + b
}

result := sum(5, 10)
fmt.Println(result) // 15
```

### **Самостоятельная работа:**
1. Написать функцию, которая принимает два числа и возвращает их сумму, разность и произведение.
2. Вызвать её в `main` и вывести результаты.

---

## **День 5: Циклы**

### **Пример 1: Классический `for`**
```go
for i := 1; i <= 5; i++ {
    fmt.Println(i)
}
```

### **Пример 2: Итерация по срезу**
```go
nums := []int{1, 2, 3, 4, 5}
for index, value := range nums {
    fmt.Println(index, value)
}
```

### **Самостоятельная работа:**
1. Написать программу, которая вычисляет сумму чисел от 1 до N (вводится пользователем).

---

# День 6: Ввод и вывод данных

В Go ввод и вывод данных осуществляется с помощью пакета `fmt`. В этом разделе мы рассмотрим основные функции для работы с вводом и выводом, их различия и примеры использования.

---

## **Функции для ввода данных**

### **1. `fmt.Scan`**
Функция `Scan` считывает данные из стандартного ввода и сохраняет их в переменные. Она ожидает ввода до тех пор, пока не будут считаны все переданные аргументы.

```go
var a, b int
fmt.Print("Введите два числа: ")
fmt.Scan(&a, &b)
fmt.Println("Вы ввели:", a, b)
```

- **Особенности:**
  - Считывает данные до первого пробела или новой строки.
  - Подходит для простого ввода нескольких значений.

---

### **2. `fmt.Scanf`**
Функция `Scanf` позволяет считывать данные с использованием форматирования. Она работает аналогично `scanf` в языке C.

```go
var name string
var age int
fmt.Print("Введите имя и возраст: ")
fmt.Scanf("%s %d", &name, &age)
fmt.Printf("Имя: %s, Возраст: %d\n", name, age)
```

- **Особенности:**
  - Позволяет задавать формат ввода.
  - Удобно для строго структурированного ввода.

---

### **3. `fmt.Scanln`**
Функция `Scanln` считывает данные до новой строки. Она прекращает чтение, когда встречает символ новой строки (`\n`).

```go
var city string
fmt.Print("Введите ваш город: ")
fmt.Scanln(&city)
fmt.Println("Ваш город:", city)
```

- **Особенности:**
  - Читает всю строку до символа новой строки.
  - Подходит для ввода строк с пробелами.

---

## **Функции для вывода данных**

### **1. `fmt.Print` и `fmt.Println`**
Функции `Print` и `Println` выводят данные в стандартный вывод. Разница в том, что `Println` добавляет символ новой строки в конце.

```go
fmt.Print("Hello, ") // Вывод без перевода строки
fmt.Println("World!") // Вывод с переводом строки
```

- **Особенности:**
  - `Print` не добавляет пробелы между аргументами.
  - `Println` добавляет пробелы между аргументами и символ новой строки в конце.

---

### **2. `fmt.Printf`**
Функция `Printf` позволяет форматировать вывод с использованием спецификаторов формата.

```go
name := "Alice"
age := 25
fmt.Printf("Имя: %s, Возраст: %d\n", name, age)
```

- **Особенности:**
  - Поддерживает форматирование (например, `%s` для строк, `%d` для чисел).
  - Удобно для вывода сложных данных.

---

### **3. `fmt.Sprintf`**
Функция `Sprintf` возвращает отформатированную строку вместо вывода в консоль.

```go
message := fmt.Sprintf("Имя: %s, Возраст: %d", "Bob", 30)
fmt.Println(message)
```

- **Особенности:**
  - Полезно для создания строк с форматированием.

---

## **Пример 1: Чтение числа от пользователя**

```go
var num int
fmt.Print("Введите число: ")
fmt.Scan(&num)
fmt.Println("Вы ввели:", num)
```

---

## **Пример 2: Калькулятор**

```go
var a, b int
var op string

fmt.Print("Введите два числа: ")
fmt.Scan(&a, &b)

fmt.Print("Введите операцию (+, -, *, /): ")
fmt.Scan(&op)

switch op {
case "+":
    fmt.Println("Результат:", a+b)
case "-":
    fmt.Println("Результат:", a-b)
case "*":
    fmt.Println("Результат:", a*b)
case "/":
    if b != 0 {
        fmt.Println("Результат:", a/b)
    } else {
        fmt.Println("Ошибка: деление на ноль")
    }
default:
    fmt.Println("Неизвестная операция")
}
```


## **Самостоятельная работа**

1. Напишите калькулятор, который принимает два числа и оператор (+, -, *, /) и выводит результат.
2. Используйте `fmt.Scan` для ввода данных.
3. Добавьте проверку на деление на ноль и вывод сообщения об ошибке, если пользователь ввёл некорректную операцию.


## **Заключение**

Функции ввода-вывода в Go (`Scan`, `Scanf`, `Scanln`, `Print`, `Println`, `Printf`) предоставляют гибкие возможности для работы с данными. Они позволяют:
- Считывать данные от пользователя.
- Форматировать вывод.
- Упрощать взаимодействие с консолью.

Освоение этих функций — важный шаг в изучении Go, так как они часто используются в реальных приложениях.

## **День 7: Итоги первой недели**

### **Сжатая информация по дням:**

###№ **День 1: Введение в Go**
- Установка Go и настройка среды.
- Первая программа: `Hello, World!`.
- Компиляция и запуск программ.

###№ **День 2: Переменные, типы данных и константы**
- Объявление переменных: `var`, `:=`.
- Основные типы данных: `int`, `float64`, `string`, `bool`.
- Константы: `const`.

###№ **День 3: Операторы и выражения**
- Арифметические операции: `+`, `-`, `*`, `/`, `%`.
- Операторы сравнения: `==`, `!=`, `>`, `<`, `>=`, `<=`.
- Логические операторы: `&&`, `||`, `!`.
- Условные операторы: `if`, `else`, `switch`.

###№ **День 4: Функции**
- Определение и вызов функций.
- Аргументы и возвращаемые значения.
- Множественные возвращаемые значения.

###№ **День 5: Циклы**
- Цикл `for`: классический, `range`.
- Итерация по массивам и срезам.

###№ **День 6: Ввод и вывод данных**
- Функции ввода: `Scan`, `Scanf`, `Scanln`.
- Функции вывода: `Print`, `Println`, `Printf`.
- Пример: калькулятор.

---

### **Тестовые вопросы:**

1. Как объявить переменную в Go? Какие способы существуют?
2. Чем отличается `var` от `:=`?
3. Какие типы данных поддерживаются в Go? Приведите примеры.
4. Как объявить константу? Можно ли изменить её значение после объявления?
5. Какие арифметические операции поддерживаются в Go?
6. Чем отличается `if` от `switch`? Когда лучше использовать `switch`?
7. Как объявить функцию в Go? Как вернуть несколько значений?
8. Как работает цикл `for`? Как итерироваться по срезу?
9. Какие функции используются для ввода данных? Чем они отличаются?
10. Как форматировать вывод с помощью `Printf`? Приведите пример.

---

### **Самостоятельная работа:**

1. **Чётное или нечётное число:**
   Напишите программу, которая проверяет, является ли введённое число чётным или нечётным.

2. **Калькулятор:**
   Создайте калькулятор, который принимает два числа и оператор (+, -, *, /), а затем выводит результат.

3. **Сумма чисел:**
   Напишите программу, которая вычисляет сумму чисел от 1 до N (N вводится пользователем).

4. **Функция с множественными возвращаемыми значениями:**
   Создайте функцию, которая принимает два числа и возвращает их сумму, разность и произведение.

5. **Итерация по срезу:**
   Напишите программу, которая итерируется по срезу строк и выводит каждую строку в верхнем регистре.

6. **Конвертер температуры:**
   Создайте программу, которая конвертирует температуру из градусов Цельсия в Фаренгейты и наоборот.

7. **Проверка на простое число:**
   Напишите программу, которая проверяет, является ли введённое число простым.

8. **Работа с константами:**
   Создайте программу, которая использует константы для хранения математических констант (например, π) и выводит их значения.

9. **Форматированный вывод:**
   Используя `Printf`, выведите таблицу умножения для числа, введённого пользователем.

10. **Обработка ошибок:**
    Напишите программу, которая запрашивает у пользователя два числа и выполняет деление. Если второе число равно нулю, выведите сообщение об ошибке.

---

### **Дополнительные задания:**

1. **Генератор случайных чисел:**
   Используя пакет `math/rand`, создайте программу, которая генерирует случайное число в заданном диапазоне.

2. **Поиск минимального и максимального числа:**
   Напишите программу, которая находит минимальное и максимальное число в срезе.

3. **Работа с датами:**
   Используя пакет `time`, создайте программу, которая выводит текущую дату и время.

4. **Шифрование строки:**
   Напишите программу, которая шифрует строку, сдвигая каждый символ на 1 позицию вперёд в таблице ASCII.

5. **Факториал числа:**
   Создайте программу, которая вычисляет факториал введённого числа.

---

### **Заключение:**

Первая неделя курса охватывает основы языка Go, включая переменные, типы данных, операторы, функции, циклы и ввод-вывод. Эти знания являются фундаментом для дальнейшего изучения языка. Практикуйтесь, решая задачи, чтобы закрепить материал и подготовиться к более сложным темам.
---

## Неделя 2. Структуры данных и управление памятью


### **День 8: Массивы и срезы**

Массивы и срезы — это основные структуры данных в Go для хранения коллекций элементов. Они используются для работы с упорядоченными наборами данных, такими как списки чисел, строк или других типов.

---

### **Массивы**

Массив — это фиксированная коллекция элементов одного типа. Размер массива задаётся при его создании и не может быть изменён.

### **Особенности массивов:**
- Размер массива является частью его типа. Например, `[3]int` и `[5]int` — это разные типы.
- Массивы передаются по значению, то есть при передаче в функцию создаётся копия массива.

### **Пример 1: Создание и использование массива**

```go
var arr [3]int = [3]int{1, 2, 3} // Создание массива из 3 элементов
fmt.Println(arr[0]) // Вывод: 1
fmt.Println(arr)    // Вывод: [1 2 3]
```

### **Пример 2: Итерация по массиву**

```go
for i := 0; i < len(arr); i++ {
    fmt.Println(arr[i])
}
```

---

### **Срезы**

Срез — это динамическая коллекция элементов, которая может изменять свой размер. Срез является ссылкой на массив и предоставляет более гибкий способ работы с данными.

### **Особенности срезов:**
- Срез не хранит данные, он ссылается на массив.
- Срез может изменять свой размер с помощью функции `append`.
- Срез передаётся по ссылке, то есть изменения в функции отражаются на оригинальном срезе.

``` **Пример 1: Создание и использование среза**

```go
nums := []int{10, 20, 30} // Создание среза
nums = append(nums, 40)   // Добавление элемента
fmt.Println(nums)         // Вывод: [10 20 30 40]
```

``` **Пример 2: Итерация по срезу**

```go
for index, value := range nums {
    fmt.Printf("Индекс: %d, Значение: %d\n", index, value)
}
```

### **Пример 3: Создание среза из массива**

```go
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4] // Срез с индексами от 1 до 3 (не включая 4)
fmt.Println(slice) // Вывод: [2 3 4]
```

---

### **Различия между массивами и срезами**

| Характеристика       | Массив                          | Срез                          |
|----------------------|---------------------------------|-------------------------------|
| Размер               | Фиксированный                   | Динамический                  |
| Передача в функцию   | По значению (копия)             | По ссылке                     |
| Изменение размера    | Невозможно                      | Возможно с помощью `append`   |
| Инициализация        | `var arr [3]int = [3]int{1,2,3}`| `slice := []int{1, 2, 3}`     |

---

### **Самостоятельная работа:**

1. **Сортировка массива:**
   Напишите программу, которая сортирует массив чисел с использованием `sort.Ints`.

```go
nums := []int{5, 2, 9, 1, 5, 6}
sort.Ints(nums)
fmt.Println(nums) // Вывод: [1 2 5 5 6 9]
```

2. **Поиск минимального и максимального значения:**
   Напишите программу, которая находит минимальное и максимальное значение в срезе.

```go
nums := []int{10, 20, 30, 40, 50}
min, max := nums[0], nums[0]
for _, num := range nums {
    if num < min {
        min = num
    }
    if num > max {
        max = num
    }
}
fmt.Printf("Минимум: %d, Максимум: %d\n", min, max)
```

3. **Сумма элементов среза:**
   Напишите программу, которая вычисляет сумму всех элементов среза.

```go
nums := []int{1, 2, 3, 4, 5}
sum := 0
for _, num := range nums {
    sum += num
}
fmt.Println("Сумма:", sum)
```

4. **Удаление элемента из среза:**
   Напишите программу, которая удаляет элемент из среза по индексу.

```go
nums := []int{10, 20, 30, 40, 50}
index := 2 // Удаляем элемент с индексом 2
nums = append(nums[:index], nums[index+1:]...)
fmt.Println(nums) // Вывод: [10 20 40 50]
```

5. **Фильтрация среза:**
   Напишите программу, которая создаёт новый срез, содержащий только чётные числа из исходного среза.

```go
nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
var evenNumbers []int
for _, num := range nums {
    if num%2 == 0 {
        evenNumbers = append(evenNumbers, num)
    }
}
fmt.Println("Чётные числа:", evenNumbers)
```

---

### **Дополнительные задания:**

1. **Обратный порядок элементов:**
   Напишите программу, которая переворачивает порядок элементов в срезе.

2. **Поиск дубликатов:**
   Напишите программу, которая находит дубликаты в срезе и выводит их.

3. **Объединение срезов:**
   Напишите программу, которая объединяет два среза в один.

4. **Срез строк:**
   Напишите программу, которая принимает срез строк и возвращает срез, содержащий только строки длиной более 5 символов.

---

### **Заключение:**

Массивы и срезы — это мощные инструменты для работы с коллекциями данных в Go. Массивы подходят для случаев, когда размер данных известен заранее, а срезы предоставляют гибкость для работы с динамическими данными. Практикуйтесь, решая задачи, чтобы лучше понять их особенности и применение.

---

## **День 9: Карты (map) и множества**

### Что такое карта (map) в Go?

Карта (map) — это встроенный тип данных в Go, который представляет собой коллекцию пар "ключ-значение". Карты используются для хранения данных, где каждое значение связано с уникальным ключом. Это похоже на словарь в других языках программирования, таких как Python или JavaScript.

### Основные характеристики карт:
- **Ключи** должны быть уникальными.
- **Значения** могут быть любого типа.
- Карты не сохраняют порядок элементов (в отличие от массивов или срезов).
- Карты динамически расширяются по мере добавления новых элементов.

### Для чего используются карты?

Карты полезны в следующих случаях:
1. **Хранение данных с быстрым доступом по ключу.** Например, словарь переводов, где ключ — это слово на одном языке, а значение — перевод на другой язык.
2. **Подсчёт частоты элементов.** Например, подсчёт количества вхождений каждого слова в тексте.
3. **Кэширование данных.** Например, хранение результатов вычислений для быстрого доступа в будущем.
4. **Группировка данных.** Например, группировка студентов по их возрасту или городу.

### Пример 1: Карта (словарь)

### Создание карты
Карта создаётся с помощью ключевого слова `map` и указания типов ключа и значения. Например:

```go
// Создание карты с ключами типа string и значениями типа int
grades := map[string]int{
    "Alice": 90,
    "Bob":   85,
```

## Получение значения по ключу

Чтобы получить значение по ключу, используйте синтаксис `map[ключ]`:

```go
fmt.Println(grades["Alice"]) // 92
```

Если ключ отсутствует в карте, возвращается нулевое значение для типа значения (например, 0 для int).

## Проверка наличия ключа

Чтобы проверить, существует ли ключ в карте, используйте второй возвращаемый параметр:

```go
value, exists := grades["Bob"]
if exists {
    fmt.Println("Bob's grade is", value)
} else {
    fmt.Println("Bob is not in the map")
}
```

## Удаление элемента

Элемент удаляется с помощью функции `delete`:

```go
delete(grades, "Bob") // Удаление элемента с ключом "Bob"
```

## Итерация по карте

Для перебора всех элементов карты используйте цикл `for` с `range`:

```go
for key, value := range grades {
    fmt.Println(key, "has a grade of", value)
}
```

## Пример 2: Подсчёт частоты слов

Карты часто используются для подсчёта частоты элементов. Например, подсчитаем, сколько раз каждое слово встречается в тексте:

```go
text := "hello world hello go world go hello"
words := strings.Fields(text) // Разбиваем текст на слова

wordCount := make(map[string]int) // Создаём карту для подсчёта

for _, word := range words {
    wordCount[word]++ // Увеличиваем счётчик для каждого слова
}

fmt.Println(wordCount) // map[go:2 hello:3 world:2]
```

## Самостоятельная работа

Создайте карту, которая хранит переводы слов с английского на русский. Например:

- "apple" → "яблоко"
- "cat" → "кот"
- "dog" → "собака"

Напишите программу, которая запрашивает у пользователя слово на английском и выводит его перевод на русский. Если слово отсутствует в карте, выведите сообщение "Перевод не найден".

Добавьте возможность добавлять новые слова и их переводы в карту.

## Заключение

Карты — это мощный инструмент в Go, который позволяет эффективно хранить и обрабатывать данные в формате "ключ-значение". Они особенно полезны для задач, где требуется быстрый доступ к данным по ключу, таких как словари, подсчёт частот или кэширование. Освоение работы с картами — важный шаг в изучении Go.


## **День 10: Структуры**

Структуры (structs) в Go позволяют создавать пользовательские типы данных, объединяющие поля разных типов. Они используются для моделирования сложных сущностей.

---

### **Основные концепции**
- Структура определяет **поля** (атрибуты) с указанием их типов.
- Поля структуры доступны через точку: `structName.FieldName`.
- Структуры передаются по значению (копируются), если не используется указатель.

---

### **Пример 1: Создание и использование структуры**

```go
type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{"Alice", 25}
    fmt.Println(p.Name) // Вывод: Alice
    fmt.Println(p.Age)  // Вывод: 25
}
```

---

### **Пример 2: Методы структур**
Методы позволяют добавить поведение к структуре. Они определяются с помощью **получателя (receiver)**.

```go
func (p Person) Greet() {
    fmt.Printf("Привет, меня зовут %s, мне %d лет!\n", p.Name, p.Age)
}

func main() {
    p := Person{"Bob", 30}
    p.Greet() // Вывод: Привет, меня зовут Bob, мне 30 лет!
}
```

---

### **Пример 3: Вложенные структуры**

```go
type Address struct {
    City    string
    Country string
}

type Employee struct {
    Name    string
    Age     int
    Address Address
}

func main() {
    emp := Employee{
        Name: "Charlie",
        Age:  28,
        Address: Address{
            City:    "Москва",
            Country: "Россия",
        },
    }
    fmt.Println(emp.Address.City) // Вывод: Москва
}
```

---

### **Самостоятельная работа**

1. **Создание структуры "Человек":**
   Создайте структуру `Person` с полями: `Name` (string), `Age` (int), `City` (string).

```go
type Person struct {
    Name string
    Age  int
    City string
}
```

2. **Метод для структуры:**
   Добавьте метод `Introduce()`, который выводит информацию о человеке в формате:  
   "Меня зовут [Name], мне [Age] лет, я живу в [City]".

3. **Сравнение структур:**
   Напишите функцию `AreEqual(p1, p2 Person) bool`, которая сравнивает два объекта `Person` по всем полям.

4. **Создание слайса структур:**
   Создайте слайс из 3 объектов `Person` и выведите информацию о каждом.

---

## **День 11: Указатели**

Указатели (pointers) хранят адрес памяти переменной. Они используются для:
- Эффективной работы с большими структурами (избегание копирования).
- Изменения значений переменных внутри функций.
- Работы с динамической памятью.

---

### **Основные концепции**
- Оператор `&` возвращает адрес переменной.
- Оператор `*` используется для разыменования указателя.
- Нулевое значение указателя — `nil`.

---

### **Пример 1: Базовое использование указателей**

```go
var a int = 10
ptr := &a        // ptr хранит адрес переменной a
fmt.Println(*ptr) // Вывод: 10
*ptr = 20        // Изменяем значение через указатель
fmt.Println(a)   // Вывод: 20
```

---

### **Пример 2: Указатели в функциях**

```go
func double(x *int) {
    *x *= 2
}

func main() {
    num := 5
    double(&num)
    fmt.Println(num) // Вывод: 10
}
```

---

### **Пример 3: Указатели на структуры**

```go
func (p *Person) SetAge(newAge int) {
    p.Age = newAge // Изменяем поле структуры через указатель
}

func main() {
    p := Person{"Dave", 40, "London"}
    p.SetAge(45)
    fmt.Println(p.Age) // Вывод: 45
}
```

---

### **Самостоятельная работа**

1. **Функция для удвоения числа:**
   Напишите функцию `DoubleNumber`, которая принимает указатель на `int` и увеличивает его значение в 2 раза.

```go
func DoubleNumber(x *int) {
    *x *= 2
}
```

2. **Обмен значений:**
   Напишите функцию `Swap`, которая меняет местами значения двух переменных через указатели.

```go
func Swap(a, b *int) {
    temp := *a
    *a = *b
    *b = temp
}
```

3. **Указатели и структуры:**
   Создайте метод `MoveTo(newCity string)` для структуры `Person`, который изменяет город через указатель.

4. **Работа с nil-указателями:**
   Напишите программу, которая проверяет, не является ли указатель `nil`, перед разыменованием.

---

### **Дополнительные задания**

1. **Динамическое выделение памяти:**
   Используйте `new()` для создания указателя на структуру `Person`.

```go
p := new(Person)
p.Name = "Eve"
```

2. **Указатели на массивы:**
   Напишите функцию, которая принимает указатель на массив и изменяет его элементы.

3. **Сравнение указателей:**
   Сравните два указателя на один и тот же объект.

---

### **Заключение**

- **Структуры** позволяют моделировать сложные сущности, объединяя данные.
- **Указатели** дают контроль над памятью и позволяют избегать копирования больших структур.
- Используйте указатели для:
  - Изменения переменных внутри функций.
  - Работы с динамическими данными.
  - Оптимизации производительности.

---

# День 12: Интерфейсы

## Что изучим:
- Определение интерфейсов
- Использование интерфейсов

## Что такое интерфейсы в Go?
Интерфейсы в Go — это способ определения набора методов, которые должны быть реализованы другими типами. Интерфейсы позволяют абстрагироваться от конкретной реализации и работать с объектами через их поведение, а не через их тип.

### Основные характеристики интерфейсов:
- Интерфейс определяет сигнатуры методов (название, параметры и возвращаемые значения), но не их реализацию.
- Любой тип, который реализует все методы интерфейса, автоматически удовлетворяет этому интерфейсу.
- Интерфейсы позволяют писать гибкий и переиспользуемый код.

## Пример 1: Простой интерфейс

### Определение интерфейса
Интерфейс определяется с помощью ключевого слова `interface`. Например, создадим интерфейс `Speaker`, который требует реализации метода `Speak()`:

```go
type Speaker interface {
    Speak() string
}
```

### Реализация интерфейса
Любой тип, который реализует метод `Speak()`, автоматически удовлетворяет интерфейсу `Speaker`. Например:

```go
type Person struct {
    Name string
}

// Реализация метода Speak для типа Person
func (p Person) Speak() string {
    return "Hello, my name is " + p.Name
}
```

### Использование интерфейса
Теперь мы можем использовать интерфейс `Speaker` для работы с объектами типа `Person`:

```go
func main() {
    p := Person{Name: "Alice"}
    var s Speaker = p // Person удовлетворяет интерфейсу Speaker
    fmt.Println(s.Speak()) // Вывод: Hello, my name is Alice
}
```

## Пример 2: Интерфейс с несколькими методами

Интерфейсы могут требовать реализации нескольких методов. Например, создадим интерфейс `Shape`, который определяет методы для вычисления площади и периметра:

```go
type Shape interface {
    Area() float64
    Perimeter() float64
}
```

### Реализация интерфейса для разных типов

Теперь реализуем интерфейс `Shape` для двух типов: `Circle` и `Rectangle`.

``` Тип Circle

```go
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}
```

``` Тип Rectangle

```go
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}
```

### Использование интерфейса
Теперь мы можем использовать интерфейс `Shape` для работы с объектами `Circle` и `Rectangle`:

```go
func printShapeInfo(s Shape) {
    fmt.Printf("Area: %.2f, Perimeter: %.2f
", s.Area(), s.Perimeter())
}

func main() {
    c := Circle{Radius: 5}
    r := Rectangle{Width: 10, Height: 5}

    printShapeInfo(c) // Вывод: Area: 78.54, Perimeter: 31.42
    printShapeInfo(r) // Вывод: Area: 50.00, Perimeter: 30.00
}
```

## Пример 3: Пустой интерфейс

Пустой интерфейс (`interface{}`) не требует реализации каких-либо методов. Это позволяет работать с любыми типами данных. Например:

```go
func printValue(v interface{}) {
    fmt.Println("Value:", v)
}

func main() {
    printValue(42)         // Вывод: Value: 42
    printValue("Hello")    // Вывод: Value: Hello
    printValue(3.14)       // Вывод: Value: 3.14
}
```

Пустые интерфейсы часто используются в функциях, которые должны принимать данные любого типа, например, в функциях для работы с JSON или базами данных.

## Самостоятельная работа

Создайте интерфейс `Animal` с методами `Sound()` (звук, который издает животное) и `Move()` (способ передвижения).

Реализуйте интерфейс `Animal` для типов `Dog`, `Cat` и `Bird`.

Напишите функцию, которая принимает объект типа `Animal` и выводит информацию о звуке и способе передвижения.

## Заключение

Интерфейсы в Go — это мощный инструмент для создания гибкого и переиспользуемого кода. Они позволяют абстрагироваться от конкретной реализации и работать с объектами через их поведение. Освоение интерфейсов — важный шаг в изучении Go, который открывает возможности для написания более модульных и тестируемых программ.

## Тестовые вопросы
1. Что такое интерфейс в Go?
2. Какой тип может удовлетворять интерфейсу?
3. Для чего используется пустой интерфейс (`interface{}`)?
4. Как проверить, что тип реализует интерфейс?

## **День 13: Обработка ошибок**

### **Теоретическая информация**

В Go ошибки обрабатываются с помощью встроенного интерфейса `error`. Это позволяет явно указывать на возможные проблемы в работе программы. В отличие от исключений в других языках, ошибки в Go — это обычные значения, которые возвращаются из функций.

### **Основные концепции:**
- **Интерфейс `error`:** В Go ошибка — это любой тип, который реализует метод `Error() string`.
- **Возврат ошибок:** Функции, которые могут завершиться с ошибкой, возвращают её как последнее значение.
- **Проверка ошибок:** После вызова функции, которая может вернуть ошибку, её нужно проверить.
- **`panic` и `recover`:** Используются для обработки критических ошибок, которые не могут быть обработаны обычным способом.

### **Пример 1: Возврат ошибки**

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("деление на ноль")
    }
    return a / b, nil
}
```

### **Пример 2: Использование `panic` и `recover`**

```go
func safeDivide(a, b float64) (result float64) {
    defer func() {
        if err := recover(); err != nil {
            result = 0
            fmt.Println("Произошла ошибка:", err)
        }
    }()
    if b == 0 {
        panic("деление на ноль")
    }
    return a / b
}
```

### **Самостоятельная работа**

1. Напишите функцию, которая делит два числа и возвращает ошибку, если делитель равен нулю.
2. Используйте `panic` и `recover` для обработки критических ошибок в вашей программе.

---

## **День 14: Итоги второй недели**

### **Теоретическая информация**

На второй неделе вы изучили:
- **Массивы и срезы:** Динамические коллекции данных.
- **Карты:** Хранение данных в формате "ключ-значение".
- **Структуры:** Пользовательские типы данных.
- **Указатели:** Работа с памятью и передача данных по ссылке.
- **Интерфейсы:** Абстракция поведения.

### **Тестовые вопросы**

1. Чем срезы отличаются от массивов?
2. Как создать карту (`map`)?
3. Как работают указатели в Go?

### **Самостоятельная работа**

1. Напишите программу, которая использует указатели, структуры и интерфейсы для моделирования простой системы управления библиотекой.

## Неделя 3. Расширенные возможности Go

## **День 15: Горутины и каналы**

### **Теоретическая информация**

Горутины — это легковесные потоки выполнения в Go, которые позволяют выполнять код параллельно. Каналы используются для обмена данными между горутинами.

### **Основные концепции:**
- **Горутины:** Запускаются с помощью ключевого слова `go`.
- **Каналы:** Используются для передачи данных между горутинами.
- **Синхронизация:** Каналы также могут использоваться для синхронизации горутин.

### **Пример 1: Запуск горутины**

```go
func printMessage() {
    fmt.Println("Hello from goroutine!")
}

go printMessage()
time.Sleep(time.Second)
```

### **Пример 2: Каналы**

```go
ch := make(chan string)

go func() {
    ch <- "Привет из горутины"
}()

fmt.Println(<-ch)
```

### **Самостоятельная работа**

1. Напишите программу, которая запускает несколько горутин для обработки данных через каналы.

---

## **День 16: Работа с файлами**

### **Теоретическая информация**

Go предоставляет мощные инструменты для работы с файлами, включая чтение, запись и управление файловой системой.

### **Основные концепции:**
- **Чтение файлов:** Используйте `os.ReadFile` или `bufio.Scanner`.
- **Запись файлов:** Используйте `os.WriteFile` или `bufio.Writer`.
- **Управление файлами:** Открытие, закрытие и удаление файлов.

### **Пример 1: Запись в файл**

```go
file, _ := os.Create("example.txt")
defer file.Close()
file.WriteString("Hello, Go!")
```

### **Пример 2: Чтение файла**

```go
data, _ := os.ReadFile("example.txt")
fmt.Println(string(data))
```

### **Самостоятельная работа**

1. Напишите программу, которая считывает файл и выводит его содержимое в консоль.

---

## **День 17: HTTP и веб-серверы**

### **Теоретическая информация**

Go предоставляет встроенную поддержку для создания HTTP-серверов и клиентов. Это позволяет легко создавать веб-приложения и API.

### **Основные концепции:**
- **HTTP-сервер:** Используйте `http.HandleFunc` для обработки запросов.
- **Маршрутизация:** Определение путей и обработчиков.
- **HTTP-клиент:** Используйте `http.Get` для выполнения запросов.

### **Пример: Простой сервер**

```go
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintln(w, "Hello, World!")
})
http.ListenAndServe(":8080", nil)
```

### **Самостоятельная работа**

1. Реализуйте простой HTTP-сервер, который отвечает "Hello, World!".

---

## **День 18: JSON и работа с API**

### **Теоретическая информация**

JSON (JavaScript Object Notation) — это популярный формат обмена данными. Go предоставляет встроенную поддержку для работы с JSON через пакет `encoding/json`.

### **Основные концепции:**
- **Кодирование JSON:** Используйте `json.Marshal` для преобразования структур в JSON.
- **Декодирование JSON:** Используйте `json.Unmarshal` для преобразования JSON в структуры.
- **Работа с API:** Используйте HTTP-клиент для получения данных из API.

### **Пример: Кодирование JSON**

```go
type User struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
}
user := User{"Alice", 30}
jsonData, _ := json.Marshal(user)
fmt.Println(string(jsonData))
```

### **Самостоятельная работа**

1. Напишите клиент для получения данных о погоде через API.

---

## **День 19: Базы данных (SQL и NoSQL)**

### **Теоретическая информация**

Go поддерживает работу с различными базами данных, включая SQL (MariaDB, PostgreSQL) и NoSQL (MongoDB).

### **Основные концепции:**
- **SQL:** Используйте пакет `database/sql` для работы с реляционными базами данных.
- **NoSQL:** Используйте драйверы для работы с MongoDB или другими NoSQL базами данных.
- **ORM:** Используйте библиотеки, такие как GORM, для упрощения работы с базами данных.

### **Пример: Подключение к MariaDB**

```go
db, err := sql.Open("mysql", "user:password@tcp(127.0.0.1:3306)/dbname")
if err != nil {
    log.Fatal(err)
}
defer db.Close()
```

### **Пример: Подключение к MongoDB**

```go
client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI("mongodb://localhost:27017"))
if err != nil {
    log.Fatal(err)
}
defer client.Disconnect(context.TODO())
```

### **Самостоятельная работа**

1. Реализуйте простую базу данных пользователей с возможностью добавления и поиска.

---

## **День 20: Тестирование и отладка**

### **Теоретическая информация**

Тестирование — это важная часть разработки программного обеспечения. Оно позволяет убедиться, что код работает корректно и соответствует требованиям.

### **Основные концепции:**
- **Юнит-тесты:** Тестирование отдельных функций или модулей.
- **Интеграционные тесты:** Тестирование взаимодействия между компонентами.
- **Отладка:** Использование инструментов для поиска и исправления ошибок.

### **Пример: Написание теста**

```go
func TestSum(t *testing.T) {
    result := sum(2, 3)
    if result != 5 {
        t.Errorf("Expected 5, got %d", result)
    }
}
```

### **Самостоятельная работа**

1. Напишите тесты для одной из предыдущих программ.

---

## **День 21: Финальный проект и итоги курса**

### **Теоретическая информация**

Финальный проект должен объединить все изученные темы, включая работу с базами данных, HTTP-серверы, обработку ошибок и тестирование.

### **Финальное задание**

1. Разработайте веб-приложение (например, TODO-лист) с базой данных и API. Приложение должно включать:
   - Регистрацию и авторизацию пользователей.
   - Возможность добавления, редактирования и удаления задач.
   - Тесты для всех основных функций.

---

Этот курс охватывает все основные аспекты языка Go, от базовых концепций до продвинутых тем. Удачи в изучении и разработке!

